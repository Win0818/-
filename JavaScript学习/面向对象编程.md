# 面向对象编程

JavaScript不区分类和实例的概念，而是通过原型(prototype) 来实现面向对象编程。

原型是指当我们创建xiaoming这个具体的学生时，并没有一个Student类型可用。恰好有一个现成的对象：

```javascript
var robot = {
  name: 'Robot',
  height: 1.6,
  run: function () {
    cosole.log(this.name + ' is running...');
  }
}
```

将robot对象改名根据它来创建小明。

于是我们把它改名为`Student`，然后创建出`xiaoming`：
```javascript
var Student = {
  name: 'Robot',
  height: 1.2,
  run: function () {
    cosole.log(this.name + ' is running...');
  }
};

var xiaoming = {
  name: '小明'
};
xiaoming._proto_ = Student;
```

代码最后一行把`xiaoming`的原型指向了对象`Student`, 看上去`xiaoming`仿佛是从`Student`继承下来的：

```javascript
xiaoming.name;
xiaoming.run();
```

`xiaoming`有自己的`name`属性，但并没有定义`run()`方法。不过，由于小明是从`Student`继承而来，只要`Student`有`run()`方法，`xiaoming`也可以调用：

​                                               ![指向](http://www.liaoxuefeng.com/files/attachments/001435287613668a73ab76ccc85411282c1b1370be41636000/l)

如果把xiaoming的原型指向其他对象：

```javascript
var Bird = {
  fly: function () {
    cosole.log(this.name + ' is flying...');
  }
};
xiaoming._proto_ = Bird;
```

现在`xiaoming`已经无法`run()`了，他已经变成了一只鸟：

```javascript
xiaoming.fly();
```

**请注意**` Object.create()` 方法可以传入一个原型对象，并创建一个基于该原型对象的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建`xiaoming`:

```javascript
//原型对象：
var Student = {
    name: 'Robot',
    height: 1.2,
    run: function () {
      cosole.log(this.name + ' is running...');
    }
}

function createStudent(name) {
  //基于Student原型创建一个新对象：
  var s = Object.create(Student);
  // 初始化新对象;
  s.name = name;
  return s;
}

var xaioming = createStudent('小明');
xiaming.run();
xiaoming._proto_ === Student; // true

```

## 创建对象



